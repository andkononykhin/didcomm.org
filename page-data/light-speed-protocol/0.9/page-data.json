{"componentChunkName":"component---src-templates-protocol-protocol-tsx","path":"/light-speed-protocol/0.9/","result":{"data":{"markdownRemark":{"html":"<h2 id=\"Roles\">Roles</h2>\n<blockquote>\n<p>See <a href=\"https://github.com/hyperledger/aries-rfcs/tree/master/concepts/0003-protocols/roles-participants-etc.md\">this note</a> for definitions of the terms \"role\", \"participant\", and \"party\".</p>\n</blockquote>\n<p>Provides a <code>formal name</code> (using backticks in markdown) for each role in the protocol, says who and how many can play each role, and describes constraints associated with those roles (e.g., \"You can only issue a credential if you have a DID on the public ledger\"). The issue of qualification for roles can also be explored (e.g., \"The holder of the credential must be known to the issuer\").</p>\n<p>The formal names for each role are important because they are used when <a href=\"https://github.com/hyperledger/aries-rfcs/tree/master/features/0031-discover-features\">agents discover one another's capabilities</a>. An agent doesn't just claim that it supports a protocol; it makes a claim about which <em>roles</em> in the protocol it supports. An agent that supports credential issuance and an agent that supports credential holding may have very different features, but they both use the <em>credential-issuance</em> protocol. By convention, role names use lower-kebab-case and are compared case-sensitively.</p>\n<h2 id=\"Connectivity\">Connectivity</h2>\n<p>Describe any assumptions about simplex vs. duplex, which parties need to talk to which parties, etc.</p>\n<h2 id=\"States\">States</h2>\n<p>This section lists the possible states that exist for each role. It also enumerates the events (often but not always messages) that can occur, including errors, and what should happen to state as a result. A formal representation of this information is provided in a <em>state machine matrix</em>. It lists events as columns, and states as rows; a cell answers the question, \"If I am in state X (=row), and event Y (=column) occurs, what happens to my state?\" The <a href=\"https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0003-protocols/tictactoe/README.md#states\">Tic Tac Toe example</a> is typical.</p>\n<p><a href=\"https://www.visual-paradigm.com/guide/bpmn/bpmn-orchestration-vs-choreography-vs-collaboration/#bpmn-choreography\">Choreography Diagrams</a> from <a href=\"http://www.bpmn.org/\">BPMN</a> are good artifacts here, as are <a href=\"http://plantuml.com/sequence-diagram\">PUML sequence diagrams</a> and <a href=\"http://agilemodeling.com/artifacts/stateMachineDiagram.htm\">UML-style state machine diagrams</a>. The matrix form is nice because it forces an exhaustive analysis of every possible event. The diagram styles are often simpler to create and consume, and the PUML and BPMN forms have the virtue that they can support line-by-line diffs when checked in with source code. However, they don't offer an easy way to see if all possible flows have been considered; what they may NOT describe isn't obvious. This--and the freedom from fancy tools--is why the matrix form is used in many early RFCs. We leave it up to the community to settle on whether it wants to strongly recommend specific diagram types.</p>\n<p>The formal names for each state are important, as they are used in <a href=\"https://github.com/hyperledger/aries-rfcs/tree/master/features/0015-acks\"><code>ack</code>s</a> and <a href=\"https://github.com/hyperledger/aries-rfcs/tree/master/features/0035-report-problem\"><code>problem-report</code>s</a>). For example, a <code>problem-report</code> message declares which state the sender arrived at because of the problem. This helps other participants to react to errors with confidence. Formal state names are also used in the agent test suite, in log messages, and so forth.</p>\n<p>By convention, state names use lower-kebab-case. They are compared case-sensitively.</p>\n<p>State management in protocols is a deep topic. For more information, please see <a href=\"https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0003-protocols/state-details.md\">State Details and State Machines</a>.</p>\n<h2 id=\"Basic-Walkthrough\">Basic Walkthrough</h2>\n<p>Explain what happens from beginning to end. in a simple instance of the protocol. The goal is not to describe all the possibilities, but to show a typical (\"happy-path\") case so people get the main idea. Provide examples of the messages and explain their fundamental meaning and usage. All possible fields may not appear; an exhaustive catalog is saved for <a href=\"#message-reference\">Message Reference</a>.</p>\n<h2 id=\"Design-By-Contract\">Design By Contract</h2>\n<p>What preconditions must be met? What invariants apply? What postconditions are guaranteed under which circumstances? What side effects can occur? What can go wrong, when -- and how do errors affect the state of each party? Consider timeouts, malformed messages, mis-sequenced messages, etc. See <a href=\"https://en.wikipedia.org/wiki/Design_by_contract\">Design By Contract</a>.</p>\n<table>\n<thead>\n<tr>\n<th>Error Code</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>out-of-memory</td>\n<td>Possible in state <code>waiting-for-commit</code> when RAM is tight. Causes protocol to be abandoned by all parties.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Security\">Security</h2>\n<p>What abuse could occur with malicious participants, eavesdroppers, denial-of-service, etc? What should be true about the <a href=\"https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0029-message-trust-contexts/README.md\">message trust contexts</a>? What should be <a href=\"https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0049-repudiation/README.md\">repudiable or non-repudiable</a>? What mechanisms does the protocol offer to cope with such issues?</p>\n<h2 id=\"Composition\">Composition</h2>\n<table>\n<thead>\n<tr>\n<th>Supported Goal Code</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>aries.pay.cash</td>\n<td>A goal code used by the Hyperledger Aries ecosystem. See RFC X.</td>\n</tr>\n<tr>\n<td>dif.pay-direct</td>\n<td>Approximately the same meaning in DIF ecosystems.</td>\n</tr>\n</tbody>\n</table>\n<p>Can this protocol be used as a co-protocol? If yes, please include a coprotocol definition like the one shown <a href=\"https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0478-coprotocols/README.md#example\">here</a>.</p>\n<h2 id=\"Message-Reference\">Message Reference</h2>\n<p>Unless the \"Messages\" section under \"Basic Walkthrough\" covered everything that needs to be known about all message fields, this is where the data type, validation rules, and semantics of each field in each message type are detailed. Enumerating possible values, or providing ABNF or regexes is encouraged. Following conventions such as <a href=\"https://github.com/hyperledger/aries-rfcs/tree/master/concepts/0074-didcomm-best-practices#date-time-conventions\">those for date- and time-related fields</a> can save a lot of time here.</p>\n<p>Each message type should be associated with one or more roles in the protocol. That is, it should be clear which roles can send and receive which message types.</p>\n<h2 id=\"Advanced-Walkthroughs\">Advanced Walkthroughs</h2>\n<p>This section is optional. It can be used to show alternate flows through\nthe protocol.</p>\n<h2 id=\"Collateral\">Collateral</h2>\n<p>This section is optional. It could be used to reference files, code,\nrelevant standards, oracles, test suites, or other artifacts that would\nbe useful to an implementer. In general, collateral should be checked in\nwith the RFC.</p>\n<h2 id=\"L10n\">L10n</h2>\n<p>If communication in the protocol involves humans, then localization of\nmessage content may be relevant. Default settings for localization of\nall messages in the protocol can be specified in an <code>l10n.json</code> file\ndescribed here and checked in with the RFC. See <a href=\"https://github.com/hyperledger/aries-rfcs/tree/master/concepts/0011-decorators#decorator-scope\">\"Decorators at Message\nType Scope\"</a>\nin the <a href=\"https://github.com/hyperledger/aries-rfcs/tree/master/features/0043-l10n\">Localization RFC</a>.</p>\n<h2 id=\"Implementations\">Implementations</h2>\n<h2 id=\"Endnotes\">Endnotes</h2>\n<h4 id=\"1\">1</h4>\n<p>Cite someone.</p>\n<h4 id=\"2\">2</h4>\n<p>Add an explanatory comment that wasn't worth including inline.</p>","frontmatter":{"title":"Light Speed Protocol","tags":["faster-than-light-travel","star-wars"],"license":"MIT","publisher":"Merciful12","status":"Production","piuri":"https://didcomm.org/light-speed-protocol/0.9","summary":"In one or two sentences, explain what problem this protocol solve, how it works, and other key characteristics.","authors":[{"name":"Your name","email":"you@github-email"},{"name":"Author without email","email":null}]},"fields":{"modifiedDate":"Mon Sep 13 2021 09:48:29 GMT+0000 (Coordinated Universal Time)","avatar":"https://avatars.githubusercontent.com/u/29834619?v=4&s=48","version":"0.9"}}},"pageContext":{"id":"36e050d7-6dc7-5174-94e2-89d3a676baf7","html":"<h2 id=\"Roles\">Roles</h2>\n<blockquote>\n<p>See <a href=\"https://github.com/hyperledger/aries-rfcs/tree/master/concepts/0003-protocols/roles-participants-etc.md\">this note</a> for definitions of the terms \"role\", \"participant\", and \"party\".</p>\n</blockquote>\n<p>Provides a <code>formal name</code> (using backticks in markdown) for each role in the protocol, says who and how many can play each role, and describes constraints associated with those roles (e.g., \"You can only issue a credential if you have a DID on the public ledger\"). The issue of qualification for roles can also be explored (e.g., \"The holder of the credential must be known to the issuer\").</p>\n<p>The formal names for each role are important because they are used when <a href=\"https://github.com/hyperledger/aries-rfcs/tree/master/features/0031-discover-features\">agents discover one another's capabilities</a>. An agent doesn't just claim that it supports a protocol; it makes a claim about which <em>roles</em> in the protocol it supports. An agent that supports credential issuance and an agent that supports credential holding may have very different features, but they both use the <em>credential-issuance</em> protocol. By convention, role names use lower-kebab-case and are compared case-sensitively.</p>\n<h2 id=\"Connectivity\">Connectivity</h2>\n<p>Describe any assumptions about simplex vs. duplex, which parties need to talk to which parties, etc.</p>\n<h2 id=\"States\">States</h2>\n<p>This section lists the possible states that exist for each role. It also enumerates the events (often but not always messages) that can occur, including errors, and what should happen to state as a result. A formal representation of this information is provided in a <em>state machine matrix</em>. It lists events as columns, and states as rows; a cell answers the question, \"If I am in state X (=row), and event Y (=column) occurs, what happens to my state?\" The <a href=\"https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0003-protocols/tictactoe/README.md#states\">Tic Tac Toe example</a> is typical.</p>\n<p><a href=\"https://www.visual-paradigm.com/guide/bpmn/bpmn-orchestration-vs-choreography-vs-collaboration/#bpmn-choreography\">Choreography Diagrams</a> from <a href=\"http://www.bpmn.org/\">BPMN</a> are good artifacts here, as are <a href=\"http://plantuml.com/sequence-diagram\">PUML sequence diagrams</a> and <a href=\"http://agilemodeling.com/artifacts/stateMachineDiagram.htm\">UML-style state machine diagrams</a>. The matrix form is nice because it forces an exhaustive analysis of every possible event. The diagram styles are often simpler to create and consume, and the PUML and BPMN forms have the virtue that they can support line-by-line diffs when checked in with source code. However, they don't offer an easy way to see if all possible flows have been considered; what they may NOT describe isn't obvious. This--and the freedom from fancy tools--is why the matrix form is used in many early RFCs. We leave it up to the community to settle on whether it wants to strongly recommend specific diagram types.</p>\n<p>The formal names for each state are important, as they are used in <a href=\"https://github.com/hyperledger/aries-rfcs/tree/master/features/0015-acks\"><code>ack</code>s</a> and <a href=\"https://github.com/hyperledger/aries-rfcs/tree/master/features/0035-report-problem\"><code>problem-report</code>s</a>). For example, a <code>problem-report</code> message declares which state the sender arrived at because of the problem. This helps other participants to react to errors with confidence. Formal state names are also used in the agent test suite, in log messages, and so forth.</p>\n<p>By convention, state names use lower-kebab-case. They are compared case-sensitively.</p>\n<p>State management in protocols is a deep topic. For more information, please see <a href=\"https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0003-protocols/state-details.md\">State Details and State Machines</a>.</p>\n<h2 id=\"Basic-Walkthrough\">Basic Walkthrough</h2>\n<p>Explain what happens from beginning to end. in a simple instance of the protocol. The goal is not to describe all the possibilities, but to show a typical (\"happy-path\") case so people get the main idea. Provide examples of the messages and explain their fundamental meaning and usage. All possible fields may not appear; an exhaustive catalog is saved for <a href=\"#message-reference\">Message Reference</a>.</p>\n<h2 id=\"Design-By-Contract\">Design By Contract</h2>\n<p>What preconditions must be met? What invariants apply? What postconditions are guaranteed under which circumstances? What side effects can occur? What can go wrong, when -- and how do errors affect the state of each party? Consider timeouts, malformed messages, mis-sequenced messages, etc. See <a href=\"https://en.wikipedia.org/wiki/Design_by_contract\">Design By Contract</a>.</p>\n<table>\n<thead>\n<tr>\n<th>Error Code</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>out-of-memory</td>\n<td>Possible in state <code>waiting-for-commit</code> when RAM is tight. Causes protocol to be abandoned by all parties.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"Security\">Security</h2>\n<p>What abuse could occur with malicious participants, eavesdroppers, denial-of-service, etc? What should be true about the <a href=\"https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0029-message-trust-contexts/README.md\">message trust contexts</a>? What should be <a href=\"https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0049-repudiation/README.md\">repudiable or non-repudiable</a>? What mechanisms does the protocol offer to cope with such issues?</p>\n<h2 id=\"Composition\">Composition</h2>\n<table>\n<thead>\n<tr>\n<th>Supported Goal Code</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>aries.pay.cash</td>\n<td>A goal code used by the Hyperledger Aries ecosystem. See RFC X.</td>\n</tr>\n<tr>\n<td>dif.pay-direct</td>\n<td>Approximately the same meaning in DIF ecosystems.</td>\n</tr>\n</tbody>\n</table>\n<p>Can this protocol be used as a co-protocol? If yes, please include a coprotocol definition like the one shown <a href=\"https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0478-coprotocols/README.md#example\">here</a>.</p>\n<h2 id=\"Message-Reference\">Message Reference</h2>\n<p>Unless the \"Messages\" section under \"Basic Walkthrough\" covered everything that needs to be known about all message fields, this is where the data type, validation rules, and semantics of each field in each message type are detailed. Enumerating possible values, or providing ABNF or regexes is encouraged. Following conventions such as <a href=\"https://github.com/hyperledger/aries-rfcs/tree/master/concepts/0074-didcomm-best-practices#date-time-conventions\">those for date- and time-related fields</a> can save a lot of time here.</p>\n<p>Each message type should be associated with one or more roles in the protocol. That is, it should be clear which roles can send and receive which message types.</p>\n<h2 id=\"Advanced-Walkthroughs\">Advanced Walkthroughs</h2>\n<p>This section is optional. It can be used to show alternate flows through\nthe protocol.</p>\n<h2 id=\"Collateral\">Collateral</h2>\n<p>This section is optional. It could be used to reference files, code,\nrelevant standards, oracles, test suites, or other artifacts that would\nbe useful to an implementer. In general, collateral should be checked in\nwith the RFC.</p>\n<h2 id=\"L10n\">L10n</h2>\n<p>If communication in the protocol involves humans, then localization of\nmessage content may be relevant. Default settings for localization of\nall messages in the protocol can be specified in an <code>l10n.json</code> file\ndescribed here and checked in with the RFC. See <a href=\"https://github.com/hyperledger/aries-rfcs/tree/master/concepts/0011-decorators#decorator-scope\">\"Decorators at Message\nType Scope\"</a>\nin the <a href=\"https://github.com/hyperledger/aries-rfcs/tree/master/features/0043-l10n\">Localization RFC</a>.</p>\n<h2 id=\"Implementations\">Implementations</h2>\n<h2 id=\"Endnotes\">Endnotes</h2>\n<h4 id=\"1\">1</h4>\n<p>Cite someone.</p>\n<h4 id=\"2\">2</h4>\n<p>Add an explanatory comment that wasn't worth including inline.</p>"}},"staticQueryHashes":["3000541721","3766577012"]}